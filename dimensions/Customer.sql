DROP TABLE IF EXISTS DIM_CUSTOMER

-- CRIAÇÃO DA TABELA DE DIMENSÃO ATOR
CREATE TABLE DIM_CUSTOMER
(
  CUSTOMER_ID  INT NOT NULL,
  FIRST_NAME VARCHAR(25) NOT NULL,
  LAST_UPDATE DATETIME NOT NULL,
  CONSTRAINT PKCUSTOMER_ID PRIMARY KEY (CUSTOMER_ID ASC)
);

-- Bloco utilizado para verificar se a SP já existe. Se SIM, o banco fará um DROP da SP e irá recriar.
IF EXISTS (
  SELECT * 
    FROM INFORMATION_SCHEMA.ROUTINES 
   WHERE 1=1
     AND SPECIFIC_NAME = N'PROC_ETL_CUSTOMER' 
)
   DROP PROCEDURE PROC_ETL_CUSTOMER;

-- CREATE THE STORED PROCEDURE 
CREATE PROCEDURE DBO.PROC_ETL_CUSTOMER
AS
BEGIN
  -- DECLARAÇÃO DAS VARIÁVEIS DE LOG E CONTROLE
  DECLARE
    --VARIÁVEIS DE TABELA
    @V_CUSTOMER_ID INT,
    @V_FIRST_NAME VARCHAR(25),
    @V_LAST_UPDATE DATETIME,
    
    --VARIÁVEIS DE CONTROLE DE DADOS PROCESSADOS
    @V_DSC_DADOS_PROCESSAMENTO VARCHAR(2000);

  -- DECLARAÇÃO DO CURSOR
  DECLARE CUR_GET_CUSTOMER CURSOR FOR
  SELECT
    ORIGEM.CUSTOMER_ID,
    ORIGEM.FIRST_NAME,
    ORIGEM.LAST_UPDATE
  FROM customer AS ORIGEM
  WHERE NOT EXISTS (SELECT DIM.CUSTOMER_ID
                    FROM DIM_CUSTOMER DIM
                    WHERE ORIGEM.CUSTOMER_ID = DIM.CUSTOMER_ID);

  -- ABRE CURSOR PARA EXECUÇÃO
  OPEN CUR_GET_CUSTOMER;

  -- CAPTURA PRIMEIRO REGISTRO PARA INICIAR O LOOP
  FETCH NEXT FROM CUR_GET_CUSTOMER
  INTO
    @V_CUSTOMER_ID,
    @V_FIRST_NAME,
    @V_LAST_UPDATE;

  -- LOOP QUE IRÁ EXECUTAR ENQUANTO HOUVER LINHAS NO CURSOR PARA SEREM PROCESSADAS
  WHILE (@@FETCH_STATUS = 0)
  BEGIN
    -- ATRIBUI VALORES PROCESSADOS
    SET @V_DSC_DADOS_PROCESSAMENTO = 'CUSTOMER_ID ' + CAST(@V_CUSTOMER_ID AS VARCHAR) + CHAR(13) + CHAR(10) +
                                     'FIRST_NAME ' + CAST(@V_FIRST_NAME AS VARCHAR);
                                     
    BEGIN TRANSACTION;
         INSERT INTO DIM_CUSTOMER
         (CUSTOMER_ID, FIRST_NAME, LAST_UPDATE)
         VALUES
         (@V_CUSTOMER_ID, @V_FIRST_NAME, @V_LAST_UPDATE);
           
         -- TRATAMENTO DE ERRO
         IF @@ERROR <> 0
         BEGIN
            ROLLBACK;
            -- EXIBE QUAL FOI O ÚLTIMO REGISTRO A SER PROCESSADO
            SELECT @V_DSC_DADOS_PROCESSAMENTO;
            -- FECHA CURSOR E LIBERA RECURSO DE MEMÓRIA
            CLOSE CUR_GET_CUSTOMER;
            DEALLOCATE CUR_GET_CUSTOMER;
            -- SAI DA SP
            RETURN;
         END -- IF
    COMMIT;
    
    -- CAPTURA PRÓXIMA LINHA DE REGISTROS PARA CONTINUAR O PROCESSAMENTO SE A REGRA DO LOOP AINDA ESTIVER VALENDO
    FETCH NEXT FROM CUR_GET_CUSTOMER
    INTO
      @V_CUSTOMER_ID,
      @V_FIRST_NAME,
      @V_LAST_UPDATE;
  END -- WHILE
  
  -- FECHA CURSOR E LIBERA RECURSO DE MEMÓRIA
  CLOSE CUR_GET_CUSTOMER;
  DEALLOCATE CUR_GET_CUSTOMER;
END;


EXEC PROC_ETL_CUSTOMER


SELECT * FROM DIM_CUSTOMER